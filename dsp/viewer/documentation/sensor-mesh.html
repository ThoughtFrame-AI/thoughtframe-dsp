<section class="mb-5">
  <h1 class="fw-bold mb-3">Sensor Mesh</h1>

  <p class="lead text-muted" style="max-width: 900px;">
    The Sensor Mesh is the runtime layer responsible for ingesting one or more
    acoustic sources, enforcing time alignment, and feeding synchronized data
    into analysis pipelines. It is designed for continuous operation under
    real-world conditions: asynchronous inputs, clock drift, and variable
    latency.
  </p>
</section>

<section class="mb-5">
  <h2 class="fw-bold mb-3">Role in the System</h2>

  <p>
    The Sensor Mesh sits at the boundary between the physical world and the
    analysis runtime. Its responsibility is deliberately narrow:
  </p>

  <ul class="ms-3">
    <li>Manage sensor lifecycles</li>
    <li>Ingest time-ordered audio chunks</li>
    <li>Optionally synchronize multiple channels</li>
    <li>Dispatch synchronized data into pipelines</li>
  </ul>

  <p class="mt-3">
    The mesh does <strong>not</strong> perform signal analysis, classification,
    or interpretation. It exists to guarantee ordering, alignment, and
    determinism before any analysis occurs.
  </p>
</section>

<section class="mb-5">
  <h2 class="fw-bold mb-3">Sensors</h2>

  <p>
    All inputs implement a common <code>AcousticSensor</code> interface.
    Sensors expose an asynchronous stream of fixed-size audio chunks, emitted
    in strict temporal order.
  </p>

  <p>
    This abstraction allows the same runtime to operate on:
  </p>

  <ul class="ms-3">
    <li>Live capture via FFmpeg (e.g. ALSA devices)</li>
    <li>Recorded audio files for replay and testing</li>
    <li>Synthetic or simulated sources</li>
  </ul>

  <p class="mt-3">
    Sensors are intentionally stateless with respect to downstream processing.
    They emit samples; they do not know how those samples will be analyzed.
  </p>
</section>

<section class="mb-5">
  <h2 class="fw-bold mb-3">Mesh Construction</h2>

  <p>
    A Sensor Mesh is assembled from configuration rather than code. Each mesh
    defines:
  </p>

  <ul class="ms-3">
    <li>One or more sensors</li>
    <li>Optional coordination stages</li>
    <li>One or more analysis pipelines</li>
  </ul>

  <p class="mt-3">
    This allows the same pipelines to be reused across different physical
    layouts — single hydrophones, towed arrays, or virtual test setups —
    without modification.
  </p>
</section>

<section class="mb-5">
  <h2 class="fw-bold mb-3">Array Coordination</h2>

  <p>
    When multiple sensors are active, the mesh may insert an
    <code>ArrayCoordinator</code>. This component enforces sample-accurate
    alignment across all input streams.
  </p>

  <p>
    Coordination is explicit and blocking: downstream processing only proceeds
    once all participating sensors have produced a corresponding chunk.
  </p>

  <p class="mt-3">
    This design prevents common failure modes in distributed sensing:
  </p>

  <ul class="ms-3">
    <li>Silent clock drift</li>
    <li>Misaligned feature extraction</li>
    <li>Ambiguous temporal relationships between channels</li>
  </ul>
</section>

<section class="mb-5">
  <h2 class="fw-bold mb-3">Concurrency Model</h2>

  <p>
    The mesh is implemented using Python’s <code>asyncio</code> runtime.
    Each sensor runs as an independent asynchronous producer.
  </p>

  <p>
    Coordination and dispatch are performed using structured concurrency
    primitives rather than background threads or implicit buffering.
  </p>

  <p class="mt-3">
    Key properties of this model:
  </p>

  <ul class="ms-3">
    <li>No shared mutable state between sensors</li>
    <li>Deterministic ordering of chunk delivery</li>
    <li>Backpressure is explicit and visible</li>
    <li>Failures propagate predictably</li>
  </ul>
</section>

<section class="mb-5">
  <h2 class="fw-bold mb-3">Pipeline Dispatch</h2>

  <p>
    Once a chunk (or synchronized set of chunks) is ready, it is dispatched
    into one or more <code>AcousticPipeline</code> instances.
  </p>

  <p>
    Multiple pipelines may consume the same data stream in parallel, allowing
    different analyses to run independently without duplicating ingestion or
    coordination logic.
  </p>

  <p class="mt-3">
    This fan-out pattern is central to the mesh design: ingestion is performed
    once, analysis scales horizontally.
  </p>
</section>

<section class="mb-5">
  <h2 class="fw-bold mb-3">Failure and Restart Behavior</h2>

  <p>
    The Sensor Mesh is designed to run for extended periods. Sensor failure,
    stream exhaustion, or transient errors are handled explicitly rather than
    implicitly retried.
  </p>

  <p>
    Because all analysis results are persisted downstream, restarting the mesh
    does not invalidate previously produced evidence. Replay can be performed
    deterministically using recorded inputs.
  </p>
</section>

<section>
  <h2 class="fw-bold mb-3">Why a Mesh</h2>

  <p>
    Treating ingestion as a mesh rather than a monolithic loop allows the system
    to scale from simple, single-channel experiments to complex multi-sensor
    deployments without architectural change.
  </p>

  <p>
    The result is a runtime that behaves predictably under real-time pressure,
    while remaining testable, inspectable, and replayable.
  </p>
</section>
